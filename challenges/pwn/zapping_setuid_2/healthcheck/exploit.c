// SPDX-License-Identifier: Apache-2.0
/*
 * Copyright 2023 Google LLC.
 */

#define _GNU_SOURCE

#include <errno.h>
#include <fcntl.h>
#include <linux/mount.h>
#include <sched.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mount.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <sys/syscall.h>
#include <unistd.h>

#ifndef error
__attribute__((weak))
void error(int status, int errnum, const char *format, ...)
{
        va_list ap;

        fprintf(stderr, "%s: ", program_invocation_name);
        va_start(ap, format);
        vfprintf(stderr, format, ap);
        va_end(ap);
        if (errnum) {
                errno = errnum;
                fprintf(stderr, ": %m");
        }
        fprintf(stderr, "\n");

        if (status)
                exit(status);
}
#endif

static void send_fd(int sock, int fd)
{
        struct msghdr msg = {};
        struct cmsghdr *cmsg;
        char buf[CMSG_SPACE(sizeof(int))] = {0}, c = 'c';
        struct iovec io = {
                .iov_base = &c,
                .iov_len = 1,
        };

        msg.msg_iov = &io;
        msg.msg_iovlen = 1;
        msg.msg_control = buf;
        msg.msg_controllen = sizeof(buf);
        cmsg = CMSG_FIRSTHDR(&msg);
        cmsg->cmsg_level = SOL_SOCKET;
        cmsg->cmsg_type = SCM_RIGHTS;
        cmsg->cmsg_len = CMSG_LEN(sizeof(int));
        *((int *)CMSG_DATA(cmsg)) = fd;
        msg.msg_controllen = cmsg->cmsg_len;

        if (sendmsg(sock, &msg, 0) < 0)
                error(1, errno, "sendmsg");
}

static int recv_fd(int sock)
{
        struct msghdr msg = {};
        struct cmsghdr *cmsg;
        char buf[CMSG_SPACE(sizeof(int))] = {0}, c = 'c';
        struct iovec io = {
                .iov_base = &c,
                .iov_len = 1,
        };

        msg.msg_iov = &io;
        msg.msg_iovlen = 1;
        msg.msg_control = buf;
        msg.msg_controllen = sizeof(buf);

        if (recvmsg(sock, &msg, 0) < 0)
                error(1, errno, "recvmsg");

        for (cmsg = CMSG_FIRSTHDR(&msg); cmsg != NULL;
             cmsg = CMSG_NXTHDR(&msg, cmsg)) {
                if (cmsg->cmsg_level == SOL_SOCKET &&
                    cmsg->cmsg_type == SCM_RIGHTS &&
                    cmsg->cmsg_len == CMSG_LEN(sizeof(int))) {
                        int fd;
                        memcpy(&fd, CMSG_DATA(cmsg), sizeof(int));
                        return fd;
                }
        }

        error(1, errno, "recv_fd: no fds received");
        __builtin_unreachable();
}

static void do_child(int sock)
{
        int fd;

        if (unshare(CLONE_NEWUSER | CLONE_NEWNS) < 0)
                error(1, errno, "unshare(CLONE_NEWUSER | CLONE_NEWNS)");
        if (mount("none", "/", NULL, MS_REC | MS_PRIVATE, NULL) < 0)
                error(1, errno, "mount(/, MS_REC | MS_PRIVATE)");
        if (mount("/usr/lib/zapps/build", "/home/user", NULL, MS_BIND, NULL))
                error(1, errno, "mount(/home/user, MS_BIND)");

        fd = open("/", O_PATH);
        if (fd < 0)
                error(1, errno, "open(/, O_PATH)");

        send_fd(sock, fd);
        pause();
        _exit(0);
}

int main(void)
{
        int pair[2];
        pid_t child;
        int fd;

        if (socketpair(AF_UNIX, SOCK_DGRAM | SOCK_CLOEXEC, 0, pair) < 0)
                error(1, errno, "socketpair");

        child = fork();
        if (child < 0)
                error(1, errno, "fork");
        if (!child)
                do_child(pair[1]);

        fd = recv_fd(pair[0]);

        fd = syscall(SYS_open_tree, fd, "", AT_EMPTY_PATH | AT_RECURSIVE |
                     OPEN_TREE_CLONE);
        if (fd < 0)
                error(1, errno, "open_tree");

        syscall(SYS_execveat, fd, "home/user/exe", NULL, NULL, 0);
        error(1, errno, "execveat");
}
